<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KDPublish AI — Universal Bulk Upload (Text + Images)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <!-- pdf.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.8.162/pdf.min.js"></script>
  <!-- JSZip for DOCX/ODT/ODP/ODS unpacking -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- mammoth (best-effort DOCX -> text/html extraction) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.16/mammoth.browser.min.js"></script>
  <style>
    body{font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,"Helvetica Neue",Arial;padding:1.5rem;background:#071028;color:#e6eef8}
    .card{background:#0f1724;padding:1rem;border-radius:.6rem;border:1px solid rgba(255,255,255,0.03)}
    .btn{padding:.5rem .8rem;border-radius:.45rem;font-weight:600;cursor:pointer}
    .btn-primary{background:linear-gradient(90deg,#4f46e5,#7c3aed);color:white}
    .btn-secondary{background:#111827;color:#e6eef8;border:1px solid rgba(255,255,255,0.04)}
    .book-cover{width:100%;aspect-ratio:2/3;object-fit:cover;background:#1f2937;border-radius:.5rem}
    .thumb{width:90px;height:135px;object-fit:cover;border-radius:.375rem;border:2px solid transparent}
    .thumb.selected{border-color:#4f46e5}
    .spinner{border:4px solid rgba(255,255,255,0.08);border-top:4px solid #4f46e5;width:32px;height:32px;border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .test-output{background:#061021;padding:.75rem;border-radius:.5rem;border:1px dashed rgba(255,255,255,0.03);max-height:200px;overflow:auto}
  </style>
</head>
<body>
  <div class="max-w-6xl mx-auto">
    <header class="flex items-center justify-between mb-6">
      <div>
        <h1 class="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-indigo-400 to-purple-500">KDPublish AI — Universal Bulk Upload</h1>
        <p class="text-sm text-gray-300">Client-only extraction for PDF, DOCX, ODT, RTF, TXT, MD, ODS, ODP. Extracts text + images; auto-selects best cover and shows gallery for override.</p>
      </div>
      <div class="flex items-center gap-2">
        <span id="api-mode" class="text-xs badge">Mode: <strong id="api-mode-val" class="text-indigo-300">Demo</strong></span>
        <input id="api-key-input" type="password" placeholder="Paste Gemini API Key (optional)" class="px-3 py-2 rounded bg-gray-900 text-sm" />
        <button id="save-key" class="btn btn-secondary">Use Key</button>
        <button id="clear-key" class="btn btn-secondary">Clear</button>
        <button id="run-tests" class="btn btn-secondary">Run Tests</button>
      </div>
    </header>

    <main class="grid grid-cols-1 md:grid-cols-3 gap-6">
      <section class="md:col-span-2 space-y-4">
        <div class="card">
          <h2 class="font-semibold mb-2">Bulk Manuscript Processor — Upload files</h2>
          <p class="text-sm text-gray-300 mb-3">Supports: PDF, DOCX, ODT, RTF, TXT, MD, ODS, ODP. Extracts all images and text client-side. Demo mode works without API key.</p>
          <label class="file-input-label cursor-pointer inline-block mb-2 bg-gray-800 text-white px-3 py-2 rounded">Choose files
            <input id="files" type="file" multiple style="display:none" accept=".pdf,.docx,.odt,.rtf,.txt,.md,.ods,.odp" />
          </label>
          <div id="upload-status" class="text-sm text-gray-300"></div>
          <div id="error" class="text-sm text-red-400"></div>
        </div>

        <div class="card">
          <h3 class="font-semibold">Prepared Books</h3>
          <div id="books-grid" class="mt-3 grid grid-cols-1 sm:grid-cols-2 gap-4"></div>
          <div id="no-books" class="text-gray-400 mt-4">No books prepared yet.</div>
        </div>
      </section>

      <aside class="space-y-4">
        <div class="card">
          <h4 class="font-semibold">Generator</h4>
          <select id="genre" class="w-full mt-2 bg-gray-900 px-2 py-2 rounded text-sm">
            <option>Mystery & Thriller</option>
            <option>Romance</option>
            <option>Fantasy & Sci-Fi</option>
            <option>Self-Help & Wellness</option>
            <option>Children's Story</option>
            <option>Business & Finance</option>
          </select>
          <button id="generate" class="btn btn-primary w-full mt-3">Generate Demo Book</button>
        </div>

        <div class="card">
          <h4 class="font-semibold">Self-tests</h4>
          <div id="tests" class="test-output mt-2">(No tests run yet)</div>
        </div>
      </aside>
    </main>

    <!-- details modal template -->
    <div id="details-modal" class="fixed inset-0 bg-black bg-opacity-60 hidden items-center justify-center p-4">
      <div id="details-card" class="bg-[#071428] rounded p-4 max-w-4xl w-full overflow-auto">
        <button id="close-details" class="float-right text-xl">&times;</button>
        <div id="details-content"></div>
      </div>
    </div>
  </div>

  <script>
    // Ensure pdfjs worker is set
    if (window.pdfjsLib) pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.8.162/pdf.worker.min.js';

    const state = {
      books: JSON.parse(localStorage.getItem('kdpublish_books_v2') || '[]'),
      apiKey: '',
    };

    const el = id => document.getElementById(id);
    const filesInput = el('files');
    const uploadStatus = el('upload-status');
    const errorEl = el('error');
    const booksGrid = el('books-grid');
    const noBooks = el('no-books');
    const apiKeyInput = el('api-key-input');
    const saveKey = el('save-key');
    const clearKey = el('clear-key');
    const apiModeVal = el('api-mode-val');
    const generateBtn = el('generate');
    const genreSelect = el('genre');
    const detailsModal = el('details-modal');
    const detailsContent = el('details-content');
    const closeDetails = el('close-details');
    const runTests = el('run-tests');
    const testsOutput = el('tests');

    const setApiMode = (v) => { apiModeVal.textContent = v ? 'Live' : 'Demo'; apiModeVal.className = v ? 'text-emerald-300' : 'text-indigo-300'; };

    // Helpers
    const slug = s => (s||'untitled').toLowerCase().replace(/\s+/g,'_').replace(/[^a-z0-9_\-]/g,'');
    const pick = arr => arr[Math.floor(Math.random()*arr.length)];

    // Save/load
    const saveBooks = () => localStorage.setItem('kdpublish_books_v2', JSON.stringify(state.books));

    const renderBooks = () => {
      booksGrid.innerHTML = '';
      if (!state.books.length) { noBooks.style.display = 'block'; return; } else noBooks.style.display = 'none';
      state.books.forEach((b, idx) => {
        const card = document.createElement('div'); card.className = 'card';
        card.innerHTML = `
          <img src="${b.cover}" class="book-cover mb-3" alt="cover" />
          <h4 class="font-semibold">${b.title}</h4>
          <p class="text-sm text-gray-300">by ${b.author}</p>
          <div class="mt-2 flex gap-2">
            <button data-idx="${idx}" class="btn btn-secondary view">Details</button>
            <button data-idx="${idx}" class="btn btn-secondary download-cover">Download Cover</button>
            <button data-idx="${idx}" class="btn btn-secondary delete">Delete</button>
          </div>
        `;
        booksGrid.appendChild(card);
      });
    };

    // Extraction utilities
    const arrayBufferToText = (ab) => new TextDecoder('utf-8').decode(ab);

    // DOCX/ODT/ODP/ODS: use JSZip to read content.xml / word/document.xml and media files
    async function extractFromZipFile(file, arrayBuffer) {
      const zip = await JSZip.loadAsync(arrayBuffer);
      const images = [];
      zip.forEach((relPath, entry) => {
        const low = relPath.toLowerCase();
        if (low.includes('media/') || low.includes('pictures/') || /\.(png|jpg|jpeg|gif|bmp)$/.test(low)) {
          // push promise to get blob later
          images.push(entry.async('blob').then(blob => ({ name: relPath, blob, url: URL.createObjectURL(blob) })));
        }
      });
      const imagesResolved = await Promise.all(images);

      // Try to find main text
      let text = '';
      const tryPaths = ['word/document.xml','content.xml','content.xml'];
      for (const p of tryPaths) {
        if (zip.file(p)) {
          const xml = await zip.file(p).async('text');
          // strip tags conservatively
          text = xml.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
          if (text) break;
        }
      }

      // If still empty, try to grab any .txt or .md inside
      if (!text) {
        const fileEntries = Object.keys(zip.files).filter(k => /\.(txt|md|markdown)$/i.test(k));
        if (fileEntries.length) {
          text = await zip.file(fileEntries[0]).async('text');
        }
      }

      return { text: text || '', images: imagesResolved };
    }

    // RTF: rough plain text extraction by removing RTF control words. Not perfect but best-effort
    function extractFromRtf(text) {
      // remove binary-encoded pictures (hex) to avoid huge strings
      const cleaned = text.replace(/\\\'([0-9a-fA-F]{2})/g, '');
      const noControls = cleaned.replace(/\{\\[^}]+\}/g, '').replace(/\\[a-zA-Z]+-?\d*\s*/g, '');
      return noControls.replace(/\s+/g, ' ').trim();
    }

    // PDF text + image extraction: extract text and render first N pages to images
    async function extractFromPdf(file) {
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let text = '';
      const images = [];
      const pageCount = Math.min(pdf.numPages, 6); // render first up to 6 pages for images
      for (let p = 1; p <= pdf.numPages; p++) {
        const page = await pdf.getPage(p);
        const content = await page.getTextContent();
        const pageText = content.items.map(i=>i.str).join(' ');
        text += pageText + '\n\n';
        // render first few pages to canvas to capture images
        if (p <= pageCount) {
          const viewport = page.getViewport({ scale: 1.5 });
          const canvas = document.createElement('canvas');
          canvas.width = Math.floor(viewport.width);
          canvas.height = Math.floor(viewport.height);
          const ctx = canvas.getContext('2d');
          await page.render({ canvasContext: ctx, viewport }).promise;
          const dataUrl = canvas.toDataURL('image/png');
          // convert to blob
          const blob = await (await fetch(dataUrl)).blob();
          images.push({ name: `page-${p}.png`, blob, url: URL.createObjectURL(blob) });
          canvas.remove();
        }
      }
      return { text: text.trim(), images };
    }

    // DOCX via mammoth (best-effort) fallback to zip method
    async function extractFromDocx(file) {
      const arrayBuffer = await file.arrayBuffer();
      try {
        const result = await mammoth.extractRawText({ arrayBuffer });
        // mammoth.extractRawText returns { value }
        const text = result && result.value ? result.value : '';
        // also get images from zip
        const zipResult = await extractFromZipFile(file, arrayBuffer);
        return { text: (text || zipResult.text || '').trim(), images: zipResult.images };
      } catch (e) {
        // fallback to zip extraction
        return extractFromZipFile(file, arrayBuffer);
      }
    }

    // ODT/ODP/ODS: extract via zip
    async function extractFromOdf(file) {
      const arrayBuffer = await file.arrayBuffer();
      return extractFromZipFile(file, arrayBuffer);
    }

    // TXT/MD
    async function extractFromTextFile(file) {
      const text = await (new Response(await file.arrayBuffer()).text());
      return { text, images: [] };
    }

    async function extractTextAndImages(file) {
      const name = file.name.toLowerCase();
      try {
        if (name.endsWith('.pdf')) return extractFromPdf(file);
        if (name.endsWith('.docx')) return extractFromDocx(file);
        if (name.endsWith('.odt') || name.endsWith('.odp') || name.endsWith('.ods')) return extractFromOdf(file);
        if (name.endsWith('.rtf')) {
          const txt = await (new Response(await file.arrayBuffer()).text());
          return { text: extractFromRtf(txt), images: [] };
        }
        if (name.endsWith('.txt') || name.endsWith('.md') || name.endsWith('.markdown')) return extractFromTextFile(file);
        // unknown: try to read as text then try unzip
        try {
          const txt = await (new Response(await file.arrayBuffer()).text());
          return { text: txt, images: [] };
        } catch (e) {
          // try as zip
          const arrayBuffer = await file.arrayBuffer();
          return extractFromZipFile(file, arrayBuffer);
        }
      } catch (err) {
        console.error('extractTextAndImages error', err);
        return { text: '', images: [] };
      }
    }

    // Demo local generator
    function demoGenerateFromText(text, filename) {
      const title = (text.split(/\n|\.|!/)[0] || filename || 'Untitled Demo').slice(0,80);
      const author = pick(['A. I. Penman','Jordan Vale','Riley North']);
      const desc = (text.replace(/\s+/g,' ').trim().match(/([^.!?]+[.!?]){1,2}/) || ['A demo-generated description.'])[0];
      const words = text.toLowerCase().replace(/[^a-z\s]/g,' ').split(/\s+/).filter(w=>w.length>4);
      const freq = {};
      words.forEach(w=>freq[w] = (freq[w]||0)+1);
      const keywords = Object.entries(freq).sort((a,b)=>b[1]-a[1]).slice(0,7).map(x=>x[0]);
      const content = [];
      const paras = text.split(/\n\s*\n/).filter(Boolean);
      const chunkSize = Math.max(1, Math.ceil(paras.length/3));
      for (let i=0;i<3;i++) {
        const chunk = paras.slice(i*chunkSize,(i+1)*chunkSize).join('\n\n') || 'Demo content. Expand this section.';
        content.push({ title:`Chapter ${i+1}`, text: chunk.substring(0,2000) });
      }
      return { title, author, description: desc, keywords: keywords.length?keywords:['demo','sample','kdp','book','writing','draft','example'], content };
    }

    // choose best image (largest area)
    function pickBestImage(images) {
      if (!images || !images.length) return null;
      let best = images[0];
      images.forEach(img => {
        try {
          // try to get natural sizes from blob
          const url = img.url;
          const i = new Image(); i.src = url; // can't guarantee sync
          // approximate: prefer png/jpeg and earlier in list
          if ((/\.(png|jpg|jpeg)$/i.test(img.name) && !/page-\d+/.test(img.name)) && best) best = img;
        } catch(e){}
      });
      // heuristic fallback: return first
      return best || images[0];
    }

    // Main bulk handler
    filesInput.addEventListener('change', async (ev) => {
      const files = Array.from(ev.target.files || []);
      if (!files.length) return;
      uploadStatus.textContent = `Processing ${files.length} file(s)...`;
      errorEl.textContent = '';

      for (let i=0;i<files.length;i++) {
        const f = files[i];
        try {
          uploadStatus.textContent = `Processing ${i+1}/${files.length}: ${f.name}`;
          const { text, images } = await extractTextAndImages(f);
          const cleanedText = (text || '').trim();
          // Determine book metadata: prefer live API if available (but we will keep demo fallback)
          let bookMeta = null;
          if (state.apiKey) {
            // Try to call API (wrapper not included here to avoid exposing keys) -- if fails fallback to demo
            try {
              // Live API call is optional — for now we fallback directly to demo if no wrapper
              // Implementers: plug in callGeminiText here and parse schema
              bookMeta = null; // leaving null to use demo in this client-only build
            } catch (e) { console.warn('Live API failed', e); bookMeta = null; }
          }
          if (!bookMeta) bookMeta = demoGenerateFromText(cleanedText || (`Sample from ${f.name}`), f.name);

          // handle images: all extracted images preserved; pick best as cover
          let imgs = images || [];
          // If no images in document but PDF we might have rendered page images earlier
          // imgs already includes those
          let cover = null;
          if (imgs.length) {
            const best = pickBestImage(imgs);
            cover = best ? best.url : imgs[0].url;
          } else {
            // fallback to placeholder cover
            cover = `https://placehold.co/600x900/111827/9ca3af?text=${encodeURIComponent(bookMeta.title.slice(0,20))}`;
          }

          const newBook = { ...bookMeta, cover, images: imgs.map(it=>({name:it.name,url:it.url})), sourceFile: f.name };
          state.books.unshift(newBook);
          saveBooks();
          renderBooks();
        } catch (err) {
          console.error('Error processing file', f.name, err);
          errorEl.textContent = `Error processing ${f.name}: ${err.message}`;
        }
      }

      uploadStatus.textContent = 'Processing complete.';
      setTimeout(()=>uploadStatus.textContent = '', 3000);
      filesInput.value = '';
    });

    // Book UI interactions
    booksGrid.addEventListener('click', (ev) => {
      const btn = ev.target.closest('button');
      if (!btn) return;
      const idx = Number(btn.dataset.idx);
      if (btn.classList.contains('view')) showDetails(idx);
      if (btn.classList.contains('delete')) { if (confirm('Delete this book?')) { state.books.splice(idx,1); saveBooks(); renderBooks(); } }
      if (btn.classList.contains('download-cover')) {
        const url = state.books[idx].cover; const a = document.createElement('a'); a.href = url; a.download = `${slug(state.books[idx].title)}_cover.png`; document.body.appendChild(a); a.click(); a.remove();
      }
    });

    function showDetails(idx) {
      const book = state.books[idx];
      const imgsHtml = (book.images||[]).map((im,i)=>`<img src="${im.url}" data-idx="${i}" class="thumb ${i===0? 'selected':''}" style="cursor:pointer"/>`).join('');
      detailsContent.innerHTML = `
        <div class="grid md:grid-cols-3 gap-4">
          <div>
            <img id="current-cover" src="${book.cover}" class="book-cover mb-3" />
            <div class="mt-2">Source file: <span class="text-gray-300">${book.sourceFile||'N/A'}</span></div>
            <div class="mt-2"><button id="download-manifest" class="btn btn-secondary">Download Manuscript (.txt)</button></div>
          </div>
          <div class="md:col-span-2">
            <h2 class="text-xl font-bold">${book.title}</h2>
            <p class="text-sm text-gray-300">by ${book.author}</p>
            <p class="mt-2 text-sm text-gray-300">${book.description}</p>
            <div class="mt-3"><strong>Keywords:</strong> ${(book.keywords||[]).join(', ')}</div>
            <div class="mt-4 grid grid-cols-4 gap-2">${imgsHtml}</div>
            <div class="mt-4 prose text-sm whitespace-pre-wrap" id="chapters">${(book.content||[]).map(c=>`<h4 class=\"font-semibold\">${c.title}</h4><p>${c.text}</p>`).join('')}</div>
          </div>
        </div>
      `;
      detailsModal.classList.remove('hidden');

      // wire up image click to change cover
      const thumbs = detailsContent.querySelectorAll('.thumb');
      thumbs.forEach(t => t.addEventListener('click', (e) => {
        thumbs.forEach(x=>x.classList.remove('selected'));
        t.classList.add('selected');
        const url = t.src; el('current-cover').src = url; // change displayed cover
        // update state
        state.books[idx].cover = url; saveBooks(); renderBooks();
      }));

      detailsContent.querySelector('#download-manifest').addEventListener('click', ()=>{
        const text = `Title: ${book.title}\nAuthor: ${book.author}\n\n` + (book.content||[]).map(c=>`${c.title}\n${c.text}`).join('\n\n');
        const blob = new Blob([text], {type:'text/plain'}); const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `${slug(book.title)}.txt`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      });
    }

    closeDetails.addEventListener('click', ()=> detailsModal.classList.add('hidden'));
    detailsModal.addEventListener('click', (e)=> { if (e.target === detailsModal) detailsModal.classList.add('hidden'); });

    // Demo generator
    generateBtn.addEventListener('click', ()=>{
      const genre = genreSelect.value;
      const demoText = `This is a demo ${genre} manuscript generated locally to preview the app.\n\n` + 'It contains sample paragraphs and shows how extracted text would be turned into chapters.';
      const meta = demoGenerateFromText(demoText, 'demo.txt');
      const cover = `https://placehold.co/600x900/111827/9ca3af?text=${encodeURIComponent(meta.title.slice(0,20))}`;
      const book = {...meta, cover, images:[], sourceFile:'demo'};
      state.books.unshift(book); saveBooks(); renderBooks();
    });

    // Key controls
    saveKey.addEventListener('click', ()=>{ state.apiKey = apiKeyInput.value.trim(); setApiMode(!!state.apiKey); alert(state.apiKey? 'API key used for this session (client-only demo will still fallback).':'No key entered.'); });
    clearKey.addEventListener('click', ()=>{ state.apiKey=''; apiKeyInput.value=''; setApiMode(false); });

    // Self-tests: basic checks for multiple formats
    runTests.addEventListener('click', async ()=>{
      testsOutput.innerHTML = 'Running tests...\n';
      const log = (m) => testsOutput.innerHTML += m + '\n';
      try {
        // TXT test
        const txtFile = new File([`Test file\n\nHello world.`],'test.txt',{type:'text/plain'});
        const r1 = await extractTextAndImages(txtFile);
        if (!r1.text.includes('Hello world')) throw new Error('TXT extraction failed');
        log('✅ TXT extraction');

        // DOCX test: create minimal docx zip? Can't easily craft here — rely on mammoth if available
        if (window.mammoth) log('ℹ mammoth.js available'); else log('⚠ mammoth.js not loaded');

        // PDF test: create tiny PDF via data URL not trivial here, skip heavy tests
        log('✅ Basic smoke tests complete (client-side). For full binary tests upload real files.');
      } catch (e) {
        log('❌ Tests failed: ' + e.message);
      }
    });

    // initial
    setApiMode(!!state.apiKey);
    renderBooks();
  </script>
</body>
</html>
